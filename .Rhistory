cl <- makeCluster(no_cores)
registerDoParallel(cl)
start_time <- Sys.time()
res <- foreach(i = 1:10000,
.combine = rbind,
.packages = c("purrr",
"dplyr",
"stringr",
"forecast",
"LTV"
)) %dopar% {
res <- get_ring_retain(start = 0.3, max = 0.99999)
tryCatch({
get_prediction_daily(diff_days = 30, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）
ring_retain_new = res$ring_retain_new,
ring_retain_old = res$ring_retain_old,
csv = FALSE,
plot = FALSE,
message = FALSE,
smooth = FALSE,
file_name = "word_game_info_base_10.csv"
)
}, error = function(e) e)
}
end_time <- Sys.time()
message("总花费时长: ", round(as.numeric(end_time) - as.numeric(start_time), 3), "秒")
stopCluster(cl)
# 从所有尝试中得到差异最小的100组,取中位数
top_res <- arrange(res, diff) %>%
head(200) %>%
separate(ring_retain_new, sep = ",", paste0("retain_new", c(2, 4, 7, 16, 30, 120, 180, 360)), convert = TRUE) %>%
select(contains("retain_new"), ring_retain_old)
par(mfrow = c(3, 3))
plot_map <- map(paste0("retain_new", c(2, 4, 7, 16, 30, 120, 180, 360)), ~hist(top_res[[.x]], breaks = 20))
best_res <- summarise_all(top_res, mean)
violence_best_retain <- list()
violence_best_retain$ring_retain_new <- select(best_res, contains("retain_new")) %>%
`[`(1,) %>%
paste0(collapse = ",")
violence_best_retain$ring_retain_old <- best_res$ring_retain_old
# info_df <- read.csv("info.csv")
get_prediction_daily(diff_days = 30, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）k
#####################################################################
prediction_retain_one = 0.48,  # 需要预测的新用户次留(计算总留存天数)
life_time_year = 1, # 预测生命周期年数
#####################################################################
ring_retain_new = violence_best_retain$ring_retain_new,
ring_retain_old = violence_best_retain$ring_retain_old,
csv = FALSE,  # 是否输出 prediction.csv
plot = TRUE,  # 是否作图
message = TRUE, # 是否打印信息
smooth = FALSE,
file_name = "word_game_info_base_10.csv"
)
cl <- makeCluster(no_cores)
registerDoParallel(cl)
start_time <- Sys.time()
res <- foreach(i = 1:10000,
.combine = rbind,
.packages = c("purrr",
"dplyr",
"stringr",
"forecast",
"LTV"
)) %dopar% {
res <- get_ring_retain(start = 0.3, max = 0.99999)
tryCatch({
get_prediction_daily(diff_days = 30, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）
ring_retain_new = res$ring_retain_new,
ring_retain_old = res$ring_retain_old,
csv = FALSE,
plot = FALSE,
message = FALSE,
smooth = FALSE,
file_name = "word_game_info_base_10.csv"
)
}, error = function(e) e)
}
end_time <- Sys.time()
message("总花费时长: ", round(as.numeric(end_time) - as.numeric(start_time), 3), "秒")
stopCluster(cl)
# 从所有尝试中得到差异最小的100组,取中位数
top_res <- arrange(res, diff) %>%
head(200) %>%
separate(ring_retain_new, sep = ",", paste0("retain_new", c(2, 4, 7, 16, 30, 120, 180, 360)), convert = TRUE) %>%
select(contains("retain_new"), ring_retain_old)
par(mfrow = c(3, 3))
plot_map <- map(paste0("retain_new", c(2, 4, 7, 16, 30, 120, 180, 360)), ~hist(top_res[[.x]], breaks = 20))
best_res <- summarise_all(top_res, mean)
violence_best_retain <- list()
violence_best_retain$ring_retain_new <- select(best_res, contains("retain_new")) %>%
`[`(1,) %>%
paste0(collapse = ",")
violence_best_retain$ring_retain_old <- best_res$ring_retain_old
require(LTV)
require(parallel)
require(doParallel)
require(dplyr)
require(purrr)
require(tidyr)
no_cores <- detectCores() - 1
# 暴力猜参数 -------------------------------------------------------------------
df_list <- make_df(file_name = "Data/word_game_info_base_10.csv", train_cr = 0.9)
# 暴力猜参数 -------------------------------------------------------------------
df_list <- make_df(file_name = "Data/word_game_info_base_10.csv", train_cr = 0.9)
library(LTV)
# 暴力猜参数 -------------------------------------------------------------------
df_list <- make_df(file_name = "Data/word_game_info_base_10.csv", train_cr = 0.9)
violence_best_retain
ring_retain_new_parameter <- c(0.922,0.92,0.948,0.9679,0.9801,0.9861,0.99,0.99)
ring_retain_new_old <- 0.97
best_retain <- get_prediction_daily(info_df = read.csv("Data/dau_appstore_new.csv"),
ring_retain_new = ring_retain_new_parameter, # 新用户环比系数
ring_retain_old = ring_retain_new_old,       # 老用户环比系数
prediction_retain_one = 0.48,                # 需要预测的新用户次留(计算总留存天数)
life_time_year = 1,                          # 预测生命周期年数
csv = FALSE,                                  # TRUE 输出 csv 文件
plot = TRUE)
ring_retain_new_parameter <- c(0.922,0.92,0.948,0.9679,0.9801,0.9861,0.99,0.99)
ring_retain_new_old <- 0.97
# 输出修改参数后的结果 --------------------------------------------------------------
best_retain <- get_prediction_daily(info_df = read.csv("Data/dau_appstore_new.csv"),
ring_retain_new = ring_retain_new_parameter, # 新用户环比系数
ring_retain_old = ring_retain_new_old,       # 老用户环比系数
prediction_retain_one = 0.48,                # 需要预测的新用户次留(计算总留存天数)
life_time_year = 1,                          # 预测生命周期年数
csv = FALSE,                                  # TRUE 输出 csv 文件
plot = TRUE)
ring_retain_new_parameter <- c(0.922,0.92,0.948,0.9679,0.9801,0.9861,0.99,0.99)
ring_retain_new_old <- 0.97
# 输出修改参数后的结果 --------------------------------------------------------------
best_retain <- get_prediction_daily(info_df = read.csv("Data/info.csv"),
ring_retain_new = ring_retain_new_parameter, # 新用户环比系数
ring_retain_old = ring_retain_new_old,       # 老用户环比系数
prediction_retain_one = 0.48,                # 需要预测的新用户次留(计算总留存天数)
life_time_year = 1,                          # 预测生命周期年数
csv = FALSE,                                  # TRUE 输出 csv 文件
plot = TRUE)
best_retain <- get_prediction_daily(info_df = read.csv("Data/info.csv"), # 以训练集拟合参数
diff_days = 20, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）
ring_retain_new = ring_retain_new_parameter,
ring_retain_old = ring_retain_new_old,
csv = FALSE,
plot = FALSE,
message = FALSE,
smooth = FALSE)
?rep_along
x <- 1:5
rep_along(x, 1:2)
rep_along(x, 1)
list_along(x)
new_users_input <- rep(1, 100)
new_users_input
system.time({
rep(1, 100000)
})
system.time({
rep(1, 10000000)
})
new_users_input <- rep(1, 1000) %>% cumsum()
head(new_users_input)
new_users_input <- runif(100, 0, 1)
retain_rates <- matrix(runif(10000, 0, 1), nrow = 100, ncol = )
new_users_input <- runif(100, 0, 1)
retain_rates <- matrix(runif(10000, 0, 1), nrow = 100, ncol = )
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
days <- 90
days <- 200
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
new_users_input <- runif(1000, 0, 1)
retain_rates <- matrix(runif(1000000, 0, 1), nrow = 100, ncol = )
days <- 200
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
new_users_input <- runif(1000, 0, 1)
retain_rates <- matrix(runif(1000000, 0, 1), nrow = 100, ncol = )
days <- 2000
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
new_users_input <- runif(1000, 0, 1)
retain_rates <- matrix(runif(1000000, 0, 1), nrow = 100, ncol = )
days <- 1000
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
days <- 1000
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
days <- 10000
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
rm(list=ls())
gc()
days <- 500
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
days <- 700
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
days <- 1000
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
days <- 3000
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
get_prediction_daily(info_df = df_list$test_df,
diff_days = 50, # 需要比较的近期天数
diff_base = 1.01, # 近期差异加权系数（乘方）k
#####################################################################
prediction_retain_one = 0.48,  # 需要预测的新用户次留(计算总留存天数)
life_time_year = 1, # 预测生命周期年数
#####################################################################
ring_retain_new = violence_best_retain$ring_retain_new,
ring_retain_old = violence_best_retain$ring_retain_old,
csv = TRUE,  # 是否输出 prediction.csv
plot = TRUE,  # 是否作图
message = TRUE, # 是否打印信息
smooth = FALSE
)
# 暴力猜参数 -------------------------------------------------------------------
df_list <- make_df(file_name = "Data/word_game_info_base_10.csv", train_cr = 0.9)
# info_df <- read.csv("info.csv")
get_prediction_daily(info_df = df_list$test_df,
diff_days = 50, # 需要比较的近期天数
diff_base = 1.01, # 近期差异加权系数（乘方）k
#####################################################################
prediction_retain_one = 0.48,  # 需要预测的新用户次留(计算总留存天数)
life_time_year = 1, # 预测生命周期年数
#####################################################################
ring_retain_new = violence_best_retain$ring_retain_new,
ring_retain_old = violence_best_retain$ring_retain_old,
csv = TRUE,  # 是否输出 prediction.csv
plot = TRUE,  # 是否作图
message = TRUE, # 是否打印信息
smooth = FALSE
)
ring_retain_new_parameter <- c(0.922,0.92,0.948,0.9679,0.9801,0.9861,0.99,0.99)
ring_retain_new_old <- 0.97
best_retain <- get_prediction_daily(info_df = read.csv("Data/info.csv"), # 以训练集拟合参数
diff_days = 20, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）
ring_retain_new = ring_retain_new_parameter,
ring_retain_old = ring_retain_new_old,
csv = FALSE,
plot = FALSE,
message = FALSE,
smooth = FALSE)
best_retain <- get_prediction_daily(info_df = read.csv("Data/info.csv"), # 以训练集拟合参数
diff_days = 20, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）
ring_retain_new = ring_retain_new_parameter,
ring_retain_old = ring_retain_new_old,
csv = FALSE,
plot = FALSE,
message = FALSE,
smooth = FALSE)
get_prediction_daily <- function(info_df, #  需要计算的数据集
diff_days = 90, #  需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数(乘方)
train_cr = 0.7,
ring_retain_new = c(0.8480, 0.9138, 0.9525, 0.9679, 0.9801, 0.9861, 0.99, 0.99), # 新用户环比系数
ring_retain_old = 0.98, # 老用户环比系数
prediction_retain_one = 0.48, # 需要预测的新用户次留(计算总留存天数)
life_time_year = 1, # 预测生命周期年数
csv = FALSE, # 是否输出 prediction.csv
plot = TRUE, # 是否作图
message = FALSE, # 是否打印信息
smooth = FALSE, # 是否先做时序分析取趋势
analysis = FALSE # 是否分析新老各段新增用户的留存贡献
) {
# 生成存储文件名所需
run_time <- format(Sys.time(), "%Y_%m_%d_%H_%M_%S")
# 文件一共有多少天(包括已有数据日及需预测日)
days <- nrow(info_df)
# 对波动较大的数据的做平滑
if (smooth) {
DAU <- ts(info_df$DAU, start = c(1,1), frequency = 7)
fit <- stl(DAU, s.window = "period", na.action = na.omit)
trend <- as_tibble(fit$time.series)$trend
info_df$DAU <- c(trend, rep(NA, days - length(trend)))
}
# 读入实际活跃,新增,次留设定,计算日的老用户活跃等
retain_users_old_daily_true <- info_df$DAU[1] - info_df$DNU[1]
retain_rate_1 <- info_df$retain_rate_1
new_users_input <- info_df$DNU
trues <- na.omit(info_df$DAU) %>% length()
# 每个环比参数影响的天数
rep_days <- c(if_max(days, 2),
if_max(days, 4),
if_max(days, 7),
if_max(days, 16),
if_max(days, 30),
if_max(days, 120),
if_max(days, 180),
if_max(days, days - 360))
# 得到各日相对于首日的环比留存率
if(is.character(ring_retain_new)) {
ring_retain_new <- stringr::str_split(ring_retain_new, ",")[[1]]
}
ring_retain_new_rates <- map2(ring_retain_new, rep_days, rep) %>%
unlist %>%
cumprod
# 老用户留存
ring_retain_old_rates <- rep(ring_retain_old, days - 1) %>%
cumprod
# 不同天留存计算成矩阵, 1为新增当日, .x为次留
retain_rates <- map(retain_rate_1, ~c(1, .x, .x * ring_retain_new_rates)) %>%
do.call(rbind, .)
# 基于第 i 天新增用户的 n 日留存率
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
# 每日所有留存加和得到每天历史新增留存的活跃
retain_users_new_daily <- colSums(retain_users_detail)[1:days] %>%
round()
# 老用户留存活跃
retain_users_old_daily <- c(retain_users_old_daily_true, retain_users_old_daily_true * ring_retain_old_rates) # 首日和缓慢衰减
# 当日总活跃
retain_users_daily <- retain_users_new_daily + retain_users_old_daily
# 将预测每日DAU写进 info_df 计算差异
info_df$retain_users_daily <- retain_users_daily[1:nrow(info_df)]
info_df$diff_rate <- info_df$retain_users_daily / info_df$DAU - 1
if (analysis) {
# 活跃中新增
info_df$retain_users_new_0 <- get_retain_users_n_days(retain_users_detail = retain_users_detail,
days = days,
start_n = 0,
end_n = 0)
# 活跃中1-7日留存
info_df$retain_users_new_7 <- get_retain_users_n_days(retain_users_detail = retain_users_detail,
days = days,
start_n = 1,
end_n = 7)
# 活跃中8-15日留存
info_df$retain_users_new_15 <- get_retain_users_n_days(retain_users_detail = retain_users_detail,
days = days,
start_n = 8,
end_n = 15)
# 活跃中16-30日留存
info_df$retain_users_new_30 <- get_retain_users_n_days(retain_users_detail = retain_users_detail,
days = days,
start_n = 16,
end_n = 30)
# 活跃中31+日留存
info_df$retain_users_new_old <- get_retain_users_n_days(retain_users_detail = retain_users_detail,
days = days,
start_n = 31,
end_n = days) + retain_users_old_daily
info_df$retain_users_new_0_cr <- round(info_df$retain_users_new_0/info_df$retain_users_daily, 3)
info_df$retain_users_new_7_cr <- round(info_df$retain_users_new_7/info_df$retain_users_daily, 3)
info_df$retain_users_new_15_cr <- round(info_df$retain_users_new_15/info_df$retain_users_daily, 3)
info_df$retain_users_new_30_cr <- round(info_df$retain_users_new_30/info_df$retain_users_daily, 3)
info_df$retain_users_new_old_cr <- round(info_df$retain_users_new_old/info_df$retain_users_daily, 3)
}
# 输出info_df
if(csv) write.csv(info_df, paste0("prediction_", run_time, ".csv"))
# 按近期加权的方法求训练数据中近期各日差异的中位数
tail_diff <- info_df$diff_rate %>%
na.omit() %>%
tail(diff_days)
tail_diff <- tail_diff[length(tail_diff):1] %>%
multiply_by(diff_base^(1:diff_days)) %>% # 越近期权重越大
abs() %>%
median() %>%
round(5)
if (message) message(paste0("训练数据共有:", trues, "日\n末", diff_days, "日加权差异绝对值为:", tail_diff*100, "%"))
# 绘图观察拟合情况
if (plot) {
df_fit <- info_df[1:trues, ]
graph_fit <- ggplot(df_fit) +
geom_line(aes(x = Date, y = DAU, color = "real")) +
geom_line(aes(x = Date, y = retain_users_daily, color = "predict")) +
scale_x_date(breaks = seq(max(df_fit$Date), min(df_fit$Date), length.out = 20)) +
scale_colour_manual(name = "fit",
values = c(real = "red",
predict = "blue"))
# 绘图观察预测情况
df_prediction <- info_df
graph_prediction <- ggplot(df_prediction) +
geom_line(aes(x = Date, y = DAU, color = "real")) +
geom_line(aes(x = Date, y = retain_users_daily, color = "predict")) +
scale_x_date(breaks = seq(max(df_prediction$Date), min(df_prediction$Date), length.out = 20)) +
scale_colour_manual(name = "predict",
values = c(real = "red",
predict = "blue"))
if(smooth) {
graph_forecast <- autoplot(fit, range.bars = 0, main = "DAU forecast")
cl <- lay_new(
matrix(1:3, nc = 1),
heights = c(2, 2, 5))
lay_grid(list(graph_fit, graph_prediction, graph_forecast), cl)
} else {
cl <- lay_new(
matrix(1:2, nc = 1),
heights = c(2, 2))
lay_grid(list(graph_fit, graph_prediction), cl)
}
}
life_time <- get_life_time(retain_users_old_daily_true = retain_users_old_daily_true,
ring_retain_new = ring_retain_new,
prediction_retain_one = prediction_retain_one,
ring_retain_old = ring_retain_old,
life_time_year = life_time_year)
res_df <- tibble(
diff = tail_diff,  # 加权差异
days = days, # 总天数
ring_retain_new = paste(ring_retain_new, collapse = ","), # 新用户环比系数
ring_retain_old = ring_retain_old,  # 老用户环比系数
life_time_new = life_time$new,
life_time_old = life_time$old,
life_time_year = life_time_year
)
if(csv) write.csv(res_df, paste0("parameter_", run_time, ".csv"))
return(res_df)
}
best_retain <- get_prediction_daily(info_df = read.csv("Data/info.csv"), # 以训练集拟合参数
diff_days = 20, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）
ring_retain_new = ring_retain_new_parameter,
ring_retain_old = ring_retain_new_old,
csv = FALSE,
plot = FALSE,
message = FALSE,
smooth = FALSE)
require(LTV)
require(parallel)
require(doParallel)
require(dplyr)
require(purrr)
require(tidyr)
no_cores <- detectCores() - 1
library(LTV)
require(LTV)
require(parallel)
require(doParallel)
require(dplyr)
require(purrr)
require(tidyr)
no_cores <- detectCores() - 1
ring_retain_new_parameter <- c(0.922,0.92,0.948,0.9679,0.9801,0.9861,0.99,0.99)
ring_retain_new_old <- 0.97
best_retain <- get_prediction_daily(info_df = read.csv("Data/info.csv"), # 以训练集拟合参数
diff_days = 20, # 需要比较的近期天数
diff_base = 1.02, # 近期差异加权系数（乘方）
ring_retain_new = ring_retain_new_parameter,
ring_retain_old = ring_retain_new_old,
csv = FALSE,
plot = FALSE,
message = FALSE,
smooth = FALSE)
days <- 3000
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
days <- 10000
new_users_input <- runif(days, 0, 1)
days <- length(new_users_input)
retain_rates <- matrix(runif(days^2, 0, 1), nrow = days, ncol = days)
system.time({
retain_users_detail <- imap(new_users_input, ~c(rep(0, .y - 1), .x * retain_rates[.y, ], rep(0, days - .y + 1))) %>%
do.call(rbind, .)
})
map
gc()
